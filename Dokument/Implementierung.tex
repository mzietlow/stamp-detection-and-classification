\chapter{Implementierung}\label{Implementierung} Der in unserem Team
aufgetretene Anwendungsfall involviert zwei Clients, die TK-App und den
Web-Client, mit jeweils unabhängigen Backendsessions. Die TK-App ist durch
Einbindung KOBILs als sicherer Client zu betrachten. Diesen Umstand zu
elaborieren überschreitet den Umfang dieser Arbeit, er ist als gegeben
hinzunehmen. Der Web-Client kommuniziert per HTTPS und nutzt secured-Cookies,
durch seine Backendanbindung ist auch er als grundsätzlich sicher einzustufen.
Bei erstmaligem Aufruf des Web-Clients wird im User-Agent des Nutzers ein neuer,
noch nicht eingeloggter TKSESSION-Cookie gesetzt. Es wird angenommen, dass der
Resource Owner bereits in der App eingeloggt ist. Zielsetzung ist nun, die im
User-Agent des Web-Clients gesetzte Session einzuloggen. Zur Verfügung stehen
die bereits aufgezählten Parteien: eingeloggte TK-App + Backend, User-Agent,
Web-Client + Backend.
\\
In ersten Überlegungen wurde die Erstellung einer neuen, eingeloggten Session
in Betracht gezogen, was sich jedoch schnell als Vergehen am Loadbalancer
herausstellte und daher verworfen wurde. Auch der Ansatz, die Session ID an die
TK-App weiterzuleiten und in ihrem Backend einzuloggen erwies sich als
undurchführbar. Um eine Session einzuloggen, muss ein Session-eigener
User-Context befüllt werden, was durch eine außerhalb liegende Session unmöglich
ist.
\\
Die App selbst ist also nicht dazu in der Lage, die Web-Session einzuloggen.
Der Login muss also über den Web-Client erfolgen. Durch diese Erkenntnis kann
auf eine klassische \gls{OAuth}-Problemstellung reduziert werden: der Web-Client
greift auf eine Login-API zu. Um diese vor unbefugten Nutzern zu schützen, setzt
der Zugriff auf sie einen Access-Token voraus. Da sich in der TK-Implementierung
von dem Access-Token intern auf den Versicherten schließen lässt, für den er
ausgestellt wurde, ist ein weiterer Parameter mit einer Nutzerkennung nicht
erforderlich.

\section{Entkoppelte Flows}
Abbildung~\ref{ls: Implicit Authorization TK} zeigt eine mögliche Realisierung
als von der App ausgehender Implicit Flow. Sie ist die einfachste Realisierung
des Anwendungsfalls. Dieses Vorgehen weist jedoch zwei wichtige Fehler auf:
zunächst dies: die einzige Verbindung zwischen App- und Web-Client, ist der in
Schritt 3 übertragene Access-Token. Web-APIs können jedoch von jedem User-Agent
aufgerufen werden. Es ist demnach anzunehmen, dass entsprechende APIs von
Dritten angegriffen werden --- und diese Angriffe erfolgreich sein werden, falls
es diesen Dritten gelingen sollte, in den Besitz eines Access-Tokens zu
gelangen. Hier also, ebenfalls in Schritt 3, findet sich der zweite Fehler. Die
Übertragung des Access-Tokens an den Web-Client erfolgt unverschlüsselt als
Query Parameter. Durch einen korrumpierten User Agent, respektive Smartphone,
könnte es einem Dritten nun möglich sein, den Access-Token zu entwenden. Da
Tokens mehrfach nutzbar sind, können Dritte sich nun durch einen Aufruf der
login/redirect-API mit dem entwendeten Token Zugang zu einer eingeloggten
Session verschaffen.
\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=25cm]{Dokument/TkFlows/implicit.ascii}
    }
    \caption{Anwendungsfall, Implicit Login Flow}\label{ls: Implicit Authorization
    TK}
\end{figure} \noindent
Eine erste Verbesserung wäre es, in Schritt 3 statt des Access-Tokens einen
Authorization Code zu versenden (Abbildung~\ref{ls: Implicit Authorization TK}).
Im Backend des Web-Clients ist die Umwandlung des Authorization Codes in einen
Access-Token von nur geringem zusätzlichem Aufwand. Die ausgestellten
Authorization Codes sollten in jedem Fall nur einmalige Gültigkeit besitzen, bei
erneuter Nutzung sollten alle eingeloggten Sessions des Resource Owners
invalidiert werden, um Replayangriffe blockieren zu können.
\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=35cm]{Dokument/TkFlows/authCode.ascii}
    }
    \caption{Anwendungsfall, Authorization Code}\label{ls: Authorization Code TK}
\end{figure} \noindent
Die Entwendung des Parameters in Schritt 3 wird auf diese Weise zwar nicht
verhindert, dadurch dass es sich jedoch nur um einen einmalig gültigen
Authorization Code handelt, ist der Wert eines Diebstahls erheblich vermindert.
Da betroffene Versicherte sich jedoch neu einloggen müssten, würde ein
derartiger Angriff dem Nutzererlebnis dennoch schaden.
\\
Um den Login eines Resource Owners in diesem Flow zu stehlen, wäre es notwendig,
die Verbindung des User-Agents zu der Web-API zu unterbinden. In einem
korrumpierten User-Agent, respektive Smartphone, wäre dies zwar wieder denkbar,
dass eine Verbindung vollkommen blockiert wird, wirkt jedoch noch
unwahrscheinlicher als der bloße Diebstahl übermittelter Daten. Davon abgesehen:
einen geschickten Angriff dieser Art würde der Resource Owner nicht wahrnehmen,
der korrumpierte User-Agent könnte ihn beispielsweise auf die Startseite der TK
redirecten. Dass Resource Owner-Identitäten auch in diesem Flow gestohlen werden
können, liegt daran, dass er keine Lösung für das erstgenannte Problem liefert:
zwischen App- und Web-Client existiert keine Kopplung. Jede Websession ist dazu
in der Lage, sich einzuloggen. Dabei ist der in Schritt 3 genutzte Parameter
irrelevant, auch ein MAC-Token, wie in Abschnitt~\ref{accessTokens} erläutert,
kann dieses Problem nicht lösen, denn jede beliebige Session wäre zu seiner,
stets identischen, Berechnung imstande.
\\

\section{Gekoppelte Flows}\label{ch:GekoppelteFlows}

Eine Möglichkeit, das Problem der Unabhängigkeit von Web-Session und App-Client
aufzulösen, ist es, den Übermittelten Access Token oder Authorization Code
asymmetrisch zu verschlüsseln. Da JWEs bereits in Kapitel \ref{ch:JWE}
angesprochen wurden, sollen sie hier als Container für die Übermittlung eines
Access-Tokens genutzt werden, auch wenn dir so entstehende Overhead fragwürdig
ist, da nur ein einziger Parameter übermittelt wird. Der in
Abbildung~\ref{ls: Extended Implicit Authorization TK} konstruierte Flow kann
jedoch auch mit anderen Container-Formaten genutzt werden.
\begin{labeling}{(5--6) Access-Token und JWE}
    \item [(1) propose/redirect] Aufruf einer
    redirect-API\label{wd:redirectApi}, die als Parameter ausschließlich einen
    redirect-Key erhält. Im ersten Schritt stellt die \nameref{wd:redirectApi}
    fest, ob die genutzte Session bereits eingeloggt ist. Falls die Session
    eingeloggt ist, wird der angefragte Redirect ausgeführt ---
    \item[(2--4) Key proposal] ist die Session jedoch ausgeloggt, so erstellt
    das Web-Backend ein neues asymmetrisches Schlüsselpaar. Der Private Key wird
    entweder direkt in der Session gespeichert oder in einer Datenbank mit der
    Session assoziiert und persistiert. Der Public Key muss in einer
    Datenbanktabelle gespeichert werden. Das ist notwendig, um in Schritt 5 zu
    verifizieren, dass der übermittelte Public Key auch tatsächlich im Backend
    erstellt wurde. Ohne diese Überprüfung könnten Drittanwendungen der App in
    Schritt 4 eigene, selbst generierte Public Keys  übergeben. Abschließend
    wird der Public Key an den App-Client zurückgeleitet.
    \item[(5--6) Access-Token und JWE] Der App-Client nimmt den Public Key
    entgegen und leitet ihn an sein Backend weiter, indem er eine Protected API
    aufruft. Diese API überprüft im ersten Schritt, ob der Public Key in der
    Datenbank eingetragen ist. Anschließend kontaktiert sie den Authorization
    Server und lässt sich einen Access-Token ausstellen. Anschließend schreibt
    sie dieses Token in ein JWE, verschlüsselt und serialisiert es. Das so
    abgesicherte JWE wird an den App-Client redirectet.
    \item[(7--8) JWE Weiterleitung] Der App-Client leitet das JWE weiter an
    den User-Agent und dieser an das Web-Client-Backend. Dazu wird eine
    API aufgerufen und das serialisierte JWE als Query Parameter angefügt.
    \item[(9) JWE Entschlüsselung] Der in Schritt 2--4 in der Session bzw.\
    einer Datenbank gespeicherte Private Key wird geladen. Anschließend wird das
    JWE entschlüsselt und der mitgelieferte Access-Token ausgelesen.
    \item[(10--11) User Identifizierung] Der in Schritt 9 ausgelesene
    Access-Token wird an den Authorization Server geleitet und von diesem
    verifiziert. Falls der Token valide ist, wird die User-ID mithilfe des
    Access-Tokens des Resource Owners ermittelt und dem Web-Client übergeben
    \item[(12--13) Login \& Redirect] Anhand der User-ID wird die Session
    eingeloggt und an die ursprünglich angefragte Seite redirectet.
\end{labeling}
\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=35cm]{Dokument/TkFlows/extendedImplicit.ascii}
    }
    \caption{Anwendungsfall, Implicit Login Flow}\label{ls: Extended Implicit Authorization TK}
\end{figure} \noindent

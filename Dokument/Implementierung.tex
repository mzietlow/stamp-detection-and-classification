\chapter{Implementierung} Der in unserem Team aufgetretene Anwendungsfall
involviert zwei Clients, die TK-App und den Web-Client, mit jeweils unabhängigen
Backendsessions. Die TK-App ist durch Einbindung KOBIls als sicherer Client zu
betrachten. Diesen Umstand zu elaborieren überschreitet jedoch den Umfang dieser
Arbeit, er ist als gegeben hinzunehmen. Der Web-Client kommuniziert per HTTPS
und nutzt secured-Cookies, durch seine Backendanbindung ist auch er als
grundsätzlich sicher einzustufen. Bei erstmaligem Aufruf des Web-Clients wird im
User-Agent des Nutzers ein neuer, noch nicht eingeloggter TKSESSION-Cookie
gesetzt. Es wird angenommen, dass der Resource Owner bereits in der App
eingeloggt ist. Zielsetzung ist nun, die im User-Agent des Web-Clients gesetzte
Session einzuloggen. Zur Verfügung stehen die bereits aufgezählten Parteien:
eingeloggte TK-App + Backend, User-Agent, Web-Client + Backend.
\todo{Passiv-Formulierungen sind nie erste Wahl. `Es wurde gezeigt, dass' ---
damit nehmen Sie dem Fazit das Gewicht. `Aus xxx ist ersichtlich, dass\ldots'}
\\
In ersten Überlegungen wurde die Erstellung einer neuen, eingeloggten Session
in Betracht gezogen, was sich jedoch schnell als Vergehen am Loadbalancer
herausstellte und daher verworfen wurde. Auch der Ansatz, die Session ID an die
TK-App weiterzuleiten und in ihrem Backend einzuloggen erwies sich als
undurchführbar. Um eine Session einzuloggen, muss ein Session-eigener
User-Context befüllt werden, was durch eine außerhalb liegende Session unmöglich
ist. \todo{redirectAPI erklären.}
\\
Die App selbst ist also nicht dazu in der Lage, die Web-Session einzuloggen.
Nur der Web-Client selbst kann dies bewerkstelligen. Durch diese Erkenntnis kann
auf eine klassische \gls{OAuth}-Problemstellung reduziert werden: der Web-Client
greift auf eine Login-API zu. Um diese vor unbefugten Nutzern zu schützen,
setzt der Zugriff auf sie einen Access-Token voraus. Auch lässt sich in der TK-
Implementierung von dem Access-Token auf den Versicherten schließen, für den er
ausgestellt wurde, ein weiterer Parameter ist also nicht erforderlich.
\section{Entkoppelte Flows}

Abbildung~\ref{ls: Implicit Authorization TK} zeigt eine mögliche Realisierung
als von der App ausgehender Implicit Flow. Sie ist die einfachste Realisierung
des Anwendungsfalls. \todo{Ausführen, weshalb einfach. Bloß ein Web-Api-Call}
Auf den zweiten Blick, weist dieses Vorgehen aber zwei wichtige Fehler auf:
zunächst dies, die einzige Verbindung zwischen App- und Web-Client, ist der in
Schritt 3 übertragene Access-Token. Web-APIs können jedoch von jedem User-Agent
aufgerufen werden. Es ist demnach anzunehmen, dass entsprechende APIs von
Dritten angegriffen --- und diese Angriffe erfolgreich sein werden, falls es
einem Dritten gelingen sollte, in den Besitz eines Access-Tokens zu gelangen.
Hier also, ebenfalls in Schritt 3, findet sich der zweite Fehler. Die
Übertragung des Access-Tokens an den Web-Client erfolgt unverschlüsselt als
Query Parameter. Durch einen korrumpierten User Agent, respektive Smartphone,
könnte es einem Dritten nun möglich sein, den Access-Token zu entwenden. Da der
Token unverschlüsselt übermittelt wurde, kann der Dritte sich durch einen Aufruf
der login/redirect-API Zugang zu einer eingeloggten Session verschaffen.
\todo{Anmerken, gegen welche Regel es verstößt, Access-Tokens zu übertragen.
Erklären, weshalb 2FA so nicht möglich ist}

\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=25cm]{Dokument/TkFlows/implicit.ascii}
    }
    \caption{Anwendungsfall, Implicit Login Flow}\label{ls: Implicit Authorization
    TK}
\end{figure} \noindent
Eine erste Verbesserung wäre es, in Schritt 3 statt
des Access-Tokens einen Authorization Code zu versenden. Im Backend des
Web-Clients ist die Umwandlung des Authorization Codes in einen Access-Token von
nur geringem zusätzlichem Aufwand. Die ausgestellten Authorization Codes sollten
in jedem Fall nur einmalige Gültigkeit besitzen, bei erneuter Nutzung sollten
alle eingeloggten Sessions des Resource Owners invalidiert werden, um
Replayangriffe auszuschließen.\todo{Literatur anführen} Abbildung~\ref{ls:
Implicit Authorization TK} zeigt den entsprechenden Flow.

\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=35cm]{Dokument/TkFlows/authCode.ascii}
    }
    \caption{Anwendungsfall, Authorization Code}\label{ls: Authorization Code TK}
\end{figure} \noindent
Die Entwendung des Parameters in Schritt 3 wird auf diese Weise zwar nicht
verhindert, dadurch dass es sich jedoch nur um einen einmalig gültigen
Authorization handelt, ist der Wert eines Diebstahls erheblich vermindert.
Um den Login eines Resource Owners in diesem Flow zu stehlen, wäre es notwendig,
die Verbindung des User-Agents zu der Web-API zu unterbinden. In einem
korrumpierten User-Agent, respektive Smartphone, wäre dies zwar wieder denkbar,
dass eine Verbindung vollkommen blockiert wird, wirkt jedoch noch
unwahrscheinlicher als der bloße Diebstahl übermittelter Daten. Davon abgesehen,
einen geschickten Angriff dieser Art würde der Resource Owner nicht wahrnehmen,
der korrumpierte User-Agent könnte ihn beispielsweise auf die Startseite der TK
redirecten. Dass Resource Owner-Identitäten auch in diesem Flow gestohlen werden
können, liegt daran, dass er keine Lösung für das erstgenannte Problem liefert:
zwischen App- und Web-Client existiert keine Kopplung. Jede Websession ist
dazu in der Lage, sich einzuloggen. Dabei ist der Parameter vollkommen egal,
auch ein MAC-Token, wie in Abschnitt~\ref{accessTokens} erläutert, kann dieses
Problem nicht lösen, denn jede beliebige Session wäre zu seiner, stets
identischen, Berechnung imstande.
\\

\section{Gekoppelte Flows}

Eine Möglichkeit, das Problem der Unabhängigkeit von Web-Session und App-Client
aufzulösen, ist es, JWEs zur Übermittlung eines Authorization Codes oder eines
Access-Tokens zu nutzen. Abbildung~\ref{ls: Extended Implicit Authorization TK}
zeigt den Flow. \todo{Spellcheck erkennt doppelte Leerzeichen nicht mehr?!}
\begin{labeling}{(5--6) Access-Token und JWE}
    \item [(1) propose/redirect] Aufruf einer API, die feststellt, ob die
    genutzte Session bereits eingeloggt ist. Als Parameter erhält sie
    ausschließlich den entsprechend redirect-Key. Falls die Session eingeloggt
    ist, wird der angefragte Redirect ausgeführt.
    \item[(2--4) Key proposal] Ist die Session jedoch ausgeloggt, so erstellt das
    Web-Backend ein neues asymmetrisches Schlüsselpaar. Der Private Key wird
    entweder direkt in der Session gespeichert oder in einer Datenbank mit der
    Session assoziiert und persistiert. Der Public Key muss in einer
    Datenbanktabelle gespeichert werden. Das ist notwendig, um in Schritt 5 zu
    verifizieren, dass der übermittelte Public Key auch tatsächlich im Backend
    erstellt wurde. Ohne diese Überprüfung könnten Drittanwendungen der App in
    Schritt 4 eigene, selbst generierte Public Keys  übergeben.
    Abschließend wird der Public Key an den App-Client zurückgeleitet.
    \item[(5--6) Access-Token und JWE] Der App-Client nimmt den Public Key
    entgegen und leitet ihn an sein Backend weiter, indem er eine Protected API
    aufruft. Diese API kontaktiert den überprüft im
    ersten Schritt, ob der Public Key in der Datenbank eingetragen ist.
    Anschließend kontaktiert sie den Authorization Server und lässt sich einen
    Access-Token ausstellen. Anschließend schreibt sie dieses Token in ein JWE,
    verschlüsselt und serialisiert es. Das so abgesicherte JWE wird an den
    App-Client redirectet.
    \item[(7--8) JWE Weiterleitung] Der App-Client leitet das JWE weiter an
    den User-Agent und dieser an das Web-Client-Backend weiter. Dazu wird eine
    API aufgerufen und das serialisierte JWE als Query Parameter angefügt.
    \item[(9) JWE Entschlüsselung] Der in Schritt 2--4 in der Session bzw.\
    einer Datenbank gespeicherte Private Key wird geladen. Anschließend wird das
    JWE entschlüsselt und der mitgelieferte Access-Token ausgelesen.
    \item[(10--11) User Identifizierung] Der in Schritt 9 ausgelesene
    Access-Token wird an den Authorization Server geleitet und von diesem
    verifiziert. Falls der Token valide ist, wird aus mithilfe des Access-Token
    die User-ID des Resource Owners ermittelt und dem Web-Client übergeben
    \item[(12--13) Login \& Redirect] Anhand der User-ID wird die Session
    eingeloggt und an die ursprünglich angefragte Seite redirectet.

\todo{JWE Erklärungen XReferenzieren}
\todo{Entscheiden, ob nach items groß oder klein geschrieben werden soll.}
\todo{Entscheiden, ob User ID, UserID oder User-ID.}
\todo{Entscheiden, ob Resource Owner, User oder Versicherter}
\todo{Entscheiden, ob und oder \&}


\end{labeling}

\begin{figure}[h]
    \scalebox{.5}{
        \lstinputlisting[linewidth=35cm]{Dokument/TkFlows/extendedImplicit.ascii}
    }
    \caption{Anwendungsfall, Implicit Login Flow}\label{ls: Extended Implicit Authorization TK}
\end{figure} \noindent
Um das Problem zu lösen muss eine Kopplung zw. App und Web entstehen, die aber vom Web ausgeht.
Momentan geht diese Kopplung ja irgendwie so halb von der App aus, die App ruft das Web auf,
eigentlich müsste das Web die App aufrufen.\\
Es muss sichergestellt sein, dass die API, nur aus der App aufgerufen werden kann.
Das ist aber möglich, da die App eigene eigene accessTokens nutzt
\todo{Flows überarbeiten, gerade den letzten Flow!}
